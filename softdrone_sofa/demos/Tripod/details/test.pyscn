# -*- coding: utf-8 -*-
"""
Step 4-2: Rigidify extremity of deformable part to be able to fix it to the actuated arms
"""
from splib.numerics import sin, cos, to_radians
from stlib.physics.deformable import ElasticMaterialObject
from actuatedarm import ActuatedArm
from splib.objectmodel import SofaPrefab, SofaObject
from stlib.physics.mixedmaterial import Rigidify
from stlib.components import addOrientedBoxRoi
from splib.numerics import vec3
from splib.numerics.quat import Quat
from tutorial import *
from splib.numerics import getOrientedBoxFromTransform
from sdsofa.utils.utils import parse_json
from softrobots.actuators import PullingCable
from stlib.physics.constraints import FixedBox

from stlib.scene import Node
from stlib.visuals import VisualModel


@SofaPrefab
class ElasticMaterialObject(SofaObject):
    """Creates an object composed of an elastic material."""

    def __init__(self,
                 attachedTo=None,
                 volumeMeshFileName=None,
                 name="ElasticMaterialObject",
                 rotation=[0.0, 0.0, 0.0],
                 translation=[0.0, 0.0, 0.0],
                 scale=[1.0, 1.0, 1.0],
                 surfaceMeshFileName=None,
                 collisionMesh=None,
                 withConstrain=True,
                 surfaceColor=[1.0, 1.0, 1.0],
                 poissonRatio=0.3,
                 youngModulus=18000,
                 totalMass=1.0, solver=None):

        self.node = Node(attachedTo, name)
        ElasticMaterialObject.createPrefab(self,
                                           volumeMeshFileName, name, rotation, translation, scale, surfaceMeshFileName,
                                           collisionMesh, withConstrain, surfaceColor, poissonRatio, youngModulus, totalMass, solver)

    @staticmethod
    def createPrefab(self,
                     volumeMeshFileName=None,
                     name="ElasticMaterialObject",
                     rotation=[0.0, 0.0, 0.0],
                     translation=[0.0, 0.0, 0.0],
                     scale=[1.0, 1.0, 1.0],
                     surfaceMeshFileName=None,
                     collisionMesh=None,
                     withConstrain=True,
                     surfaceColor=[1.0, 1.0, 1.0],
                     poissonRatio=0.3,
                     youngModulus=18000,
                     totalMass=1.0, solver=None):

        self.node.createObject("EulerImplicitSolver")
        solver = self.node.createObject("CGLinearSolver", iterations=25, name="linear_solver", tolerance="1.0e-9", threshold="1.0e-9")
        
        # self.dofs = self.node.createObject("MechanicalObject", name="dofs")
        
        # self.node = self.node.createChild("self.node")
        loader = self.node.createObject("MeshVTKLoader", filename="/home/subella/catkin_ws2/src/SoftDrone-ROS/softdrone_sofa/mesh/simple_finger_2.vtk", scale="1")
        self.node.createObject("Mesh", src=loader)
        self.node.createObject("TetrahedronSetTopologyContainer", name="Container", src=loader)
        self.node.createObject("MechanicalObject", name='dofs', template='Vec3d')
        self.node.createObject("UniformMass")
        self.node.createObject("TetrahedronHyperelasticityFEMForceField", name="FEM", ParameterSet="1e5 31034.483", materialName="NeoHookean")

        # self.node.createObject('LinearSolverConstraintCorrection', solverName=solver.name)
        self.node.createObject('UncoupledConstraintCorrection')

def ElasticBody(parent):
    body = parent.createChild("ElasticBody")

    e = ElasticMaterialObject(body,
                              volumeMeshFileName="/home/subella/catkin_ws2/src/SoftDrone-ROS/softdrone_sofa/mesh/simple_finger_2.vtk",
                              # volumeMeshFileName="data/mesh/winch3mm.vtk",
                              translation=[0.0, 0, 0.0], rotation=[0, 0, 0],
                              youngModulus=10000, poissonRatio=.4, totalMass=40)

    # visual = body.createChild("Visual")
    # visual.createObject("MeshSTLLoader", name="loader", filename="data/mesh/tripod_mid.stl")
    # visual.createObject("OglModel", name="renderer", src="@loader", color=[1.0, 1.0, 1.0, 0.5],
    #                     rotation=[90, 0, 0], translation=[0, 30, 0])

    # visual.createObject("BarycentricMapping",
    #                     input=e.dofs.getLinkPath(),
    #                     output=visual.renderer.getLinkPath())

    return body


@SofaPrefab
class Tripod(SofaObject):

    def __init__(self, parent, name="Tripod", radius=60, numMotors=3, angleShift=180.0):
        self.node = parent.createChild(name)
        self.body = ElasticBody(self.node)
        

        # dist = radius
        # numstep = numMotors
        # self.actuatedarms = []
        # for i in range(0, numstep):
        #     name = "ActuatedArm"+str(i)
        #     translation, eulerRotation = self.__getTransform(i, numstep, angleShift, radius, dist)
        #     arm = ActuatedArm(self.node, name=name,
        #                       translation=translation, eulerRotation=eulerRotation)
        #     self.actuatedarms.append(arm)
        #     # Add limits to angle that correspond to limits on real robot
        #     arm.ServoMotor.minAngle = -2.0225
        #     arm.ServoMotor.maxAngle = -0.0255

        self.__attachToActuatedArms(radius, numMotors, angleShift)

    def __getTransform(self, index, numstep, angleShift, radius, dist):
        fi = float(index)
        fnumstep = float(numstep)
        angle = fi*360/fnumstep
        angle2 = fi*360/fnumstep+angleShift
        eulerRotation = [0, angle, 0]
        translation = [dist*sin(to_radians(angle2)), -1.35, dist*cos(to_radians(angle2))]

        return translation, eulerRotation

    def __attachToActuatedArms(self, radius=60, numMotors=3, angleShift=180.0):
        deformableObject = self.node.ElasticBody.ElasticMaterialObject
        box = FixedBox(deformableObject, atPositions=[-50,-10,-50,50,0,50],
                      doVisualization=True)
        box.BoxROI.init()
        print box.BoxROI.indices

        dist = radius
        numstep = numMotors
        groupIndices = []
        # groupIndices.append([ind[0] for ind in box.BoxROI.indices])
        frames = []
        self.all_eyelet_locations = parse_json("/home/subella/catkin_ws2/src/SoftDrone-ROS/softdrone_sofa/mesh/finger_30x35_eyelets.json")["tendons"]
        for eyelets_wrt_finger_translations in self.all_eyelet_locations:
            for eyelet_wrt_finger_translation in eyelets_wrt_finger_translations:
                box = addOrientedBoxRoi(self.node, position=deformableObject.dofs.getData("rest_position"), name="BoxROI",
                                    translation=eyelet_wrt_finger_translation, scale=[8, 8, 40])
                box.init()
                deformableObject.init()
                groupIndices.append([ind[0] for ind in box.indices])

            cable = PullingCable(deformableObject,
                                 valueType="displacement",
                                 # pullPointLocation=eyelets_wrt_finger_translations[0][0],
                                 cableGeometry=eyelets_wrt_finger_translations)
            cable = cable.getObject("CableConstraint")
            cable.value = 0

        # # Rigidify the deformable part at extremity to attach arms
        # rigidifiedstruct = Rigidify(self.node, deformableObject, groupIndices=groupIndices, name="RigidifiedStructure")
        # rigidifiedstruct.DeformableParts.createObject("UncoupledConstraintCorrection")
        # rigidifiedstruct.RigidParts.createObject("UncoupledConstraintCorrection")

        # # Use this to activate some rendering on the rigidified object
        # setData(rigidifiedstruct.RigidParts.dofs, showObject=False, showObjectScale=10, drawMode=2)
        # setData(rigidifiedstruct.RigidParts.RigidifiedParticules.dofs, showObject=True, showObjectScale=1,
        #         drawMode=1, showColor=[1., 1., 0., 1.])
        # setData(rigidifiedstruct.DeformableParts.dofs, showObject=False, showObjectScale=1, drawMode=2)

        # # Attach arms
        # for i in range(0, numstep):
        #     rigidifiedstruct.RigidParts.createObject('RestShapeSpringsForceField', name="rssff"+str(i),
        #                                              points=i,
        #                                              external_rest_shape=self.actuatedarms[i].servoarm.dofs,
        #                                              stiffness='1e12', angularStiffness='1e12')


def createScene(rootNode):
    from splib.animation import animate
    from fixingbox import FixingBox
    import math

    scene = Scene(rootNode, plugins=["SoftRobots",
                                     "SofaSparseSolver"])

    scene.VisualStyle.displayFlags = "showBehavior"
    rootNode.dt = 0.01

    tripod = Tripod(scene.Modelling)
    # FixingBox(tripod, tripod.ElasticBody.ElasticMaterialObject, scale=[100, 10, 100], translation=[0., 0, 0.])
    # tripod.FixingBox.BoxROI.drawBoxes = True

    # scene.Simulation.addChild(tripod.RigidifiedStructure)
    # scene.Simulation.addChild(tripod.ActuatedArm0)
    # scene.Simulation.addChild(tripod.ActuatedArm1)
    # scene.Simulation.addChild(tripod.ActuatedArm2)

    def myanimate(targets, factor):
        for arm in targets:
            arm.ServoMotor.angleIn = -factor*math.pi/4.

    animate(myanimate, {"targets": []}, duration=1)