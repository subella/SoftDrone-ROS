#!/usr/bin/env python
"""Script to get a positions/velocities/lengths trajectory."""
import sys

import rospy
import numpy as np
import geometry_msgs.msg

import softdrone_core
from softdrone.python.control.find_trajectory import find_trajectory_for_interp


grasp_target = None

def pose_handler(msg):
    """Wait for start pose."""
    global grasp_target
    if grasp_target is None:
        grasp_target = np.array(
            [msg.pose.position.x, msg.pose.position.y, msg.pose.position.z]
        )


def main():
    """Run everything."""
    global grasp_target
    rospy.init_node("trajectory_tracking")

    use_mocap_target = rospy.get_param("~use_mocap_target", True)
    grasp_time = rospy.get_param("~grasp_time", 3.0)
    open_distance = rospy.get_param("~open_distance", 0.1)
    gripper_latency = rospy.get_param("~gripper_latency", 0.0)
    trajectory_settle_time = rospy.get_param("~trajectory_settle_time", 0.2)

    planner = find_trajectory_for_interp

    if use_mocap_target:
        rospy.logwarn("Waiting for grasp target")
        target_sub = rospy.Subscriber(
            "grasp_target", geometry_msgs.msg.PoseStamped, pose_handler, queue_size=10
        )

        while not rospy.is_shutdown() and grasp_target is None:
            rospy.sleep(rospy.Duration(0.1))

        if grasp_target is None:
            rospy.logwarn("ROS shutdown before planning ocurred.")
            return
    else:
        grasp_target = np.array(
            rospy.get_param("~grasp_target", [2.9065, 0.0878, 0.6774])
        )

    mocap_offset = np.array(rospy.get_param("~mocap_offset", [0.25, 0, 0.0]))
    rospy.loginfo("Mocap offset: {}".format(mocap_offset))
    grasp_target = grasp_target + mocap_offset

    start_position = np.array(rospy.get_param("~start_position", [0, 0, 1.5]))
    grasp_position = grasp_target - np.array(rospy.get_param("~offset", [0, 0, -0.20]))

    trajectory_plane = rospy.get_param("~trajectory_plane", "yz")
    if trajectory_plane == "yz":
        start_position[0] = grasp_position[0]  # force planar trajectory
    elif trajectory_plane == "xz":
        start_position[1] = grasp_position[1]
    else:
        rospy.logwarn("Invalid plane: {} Defaulting to yz".format(trajectory_plane))
        start_position[0] = grasp_position[0]  # force planar trajectory

    grasp_velocity = np.array(rospy.get_param("~grasp_velocity", [0, 0, 0]))

    end_time = np.array(rospy.get_param("~end_time", 2))
    end_velocity = np.array(rospy.get_param("~end_velocity", [0, 0, 0]))
    end_offset = np.array(rospy.get_param("~end_offset", [0, 0, 0]))
    end_position = grasp_position + end_offset

    rospy.loginfo("Start: {}".format(start_position))
    rospy.loginfo("Grasp Position: {}".format(grasp_position))
    rospy.loginfo("Grasp Velocity: {}".format(grasp_velocity))
    rospy.loginfo("Grasp Target: {}".format(grasp_target))
    rospy.loginfo("End Position: {}".format(end_position))
    polynomial, lengths = planner(
        start_position=start_position,
        grasp_axis=(0 if trajectory_plane == "xz" else 2),
        grasp_position=grasp_position,
        grasp_target=grasp_target,
        grasp_time=grasp_time,
        grasp_velocity=grasp_velocity,
        open_distance=open_distance,
        use_offline_lengths=True,
        end_time=end_time,
        end_position=end_position,
        end_velocity=end_velocity,
    )

    interped_start = polynomial.interp(0.0)[0]
    print(
        "Given start: {} Solution: {}".format(
            np.squeeze(start_position), np.squeeze(interped_start)
        )
    )
    assert np.linalg.norm(interped_start - start_position) < 1.0e-3
    print("Initial, Open, Grasp lengths: {}".format(lengths))

    # Set up the things that will make this run
    trajectory_tracker = softdrone_core.InterpTrajectoryTracker(
        polynomial,
        lengths,
        gripper_latency=gripper_latency,
        settle_time=trajectory_settle_time,
    )
    state_machine = softdrone_core.GraspStateMachine(trajectory_tracker)  # NOQA

    rospy.spin()


if __name__ == "__main__":
    main()
