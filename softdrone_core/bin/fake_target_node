#!/usr/bin/env python
import rospy
import numpy as np
from geometry_msgs.msg import PoseWithCovarianceStamped
import tf


#self._takeoff_offset = rospy.get_param("~takeoff_offset", 1.0)
rospy.init_node('fake_target_node')
target_motion = rospy.get_param("~target_motion", 'circle')
radius = rospy.get_param("~radius", 1.0)
speed = rospy.get_param("~speed", 1.0)
height = rospy.get_param("~height", 0.0)
xc = rospy.get_param("~x", 0.0)
yc = rospy.get_param("~y", 0.0)

circumference = 2.0*np.pi*radius

target_pub = rospy.Publisher("/sparkgrasptar/world", PoseWithCovarianceStamped, queue_size=1)

period = circumference / speed
msg = PoseWithCovarianceStamped()
msg.pose.covariance = (0.001*np.eye(6).flatten()).tolist()
rate = rospy.Rate(20)
while not rospy.is_shutdown():
    t = rospy.Time.now().to_sec()
    if target_motion == 'circle':
        x = xc + radius * np.cos(2.0*np.pi*t/period)
        y = yc + radius * np.sin(2.0*np.pi*t/period)
        q = [0,0,0,1]
    elif target_motion == 'stationary':
        x = xc
        y = yc
        q = [0,0,0,1]
    elif target_motion == 'rotating':
        x = xc
        y = yc
        theta = speed * t * 2*np.pi
        q = tf.transformations.quaternion_from_euler(0,0,theta)

    msg.header.stamp = rospy.Time.now()
    msg.header.frame_id = 'map'
    msg.pose.pose.position.x = x
    msg.pose.pose.position.y = y
    msg.pose.pose.position.z = height
    msg.pose.pose.orientation.x = q[0]
    msg.pose.pose.orientation.y = q[1]
    msg.pose.pose.orientation.z = q[2]
    msg.pose.pose.orientation.w = q[3]

    target_pub.publish(msg)
    rate.sleep()

