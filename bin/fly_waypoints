#!/usr/bin/env python
"""Script that uses position control to fly waypoints."""
import rospy
import geometry_msgs.msg
import mavros_msgs.msg
import std_msgs.msg
import enum
import math


class State(enum.Enum):
    WAITING_FOR_HOME = 0
    WAITING_FOR_ARM = 1
    EXECUTING_MISSION = 2


class WaypointNode:
    """Class for sending waypoints to the drone."""

    def __init__(self):
        """Set everything up."""
        control_rate = rospy.get_param("~control_rate", 100)
        if control_rate < 20.0:
            rospy.logfatal("Invalid control rate, must be above 20 hz")
            rospy.signal_shutdown("invalid control rate")
            return

        self._x_size = rospy.get_param("~x_size", 0.5)
        self._y_size = rospy.get_param("~y_size", 0.5)
        self._num_repeats = rospy.get_param("~num_repeats", 3)
        self._dist_threshold = rospy.get_param("~dist_threshold", 0.3)
        self._waypoint_state = State.WAITING_FOR_HOME
        self._current_state = None
        self._current_pose = None
        self._home_pose = None
        self._waypoints = []
        self._waypoint_index = 0
        self._last_pose_time = None
        self._pose_timeout = rospy.get_param("~pose_timeout", 5.0)

        self._state_sub = rospy.Subscriber(
            "state", mavros_msgs.msg.State, self._state_callback, queue_size=10
        )
        self._pose_sub = rospy.Subscriber(
            "pose", geometry_msgs.msg.PoseStamped, self._pose_callback, queue_size=10
        )
        self._target_pub = rospy.Publisher(
            "target", geometry_msgs.msg.PoseStamped, queue_size=10
        )
        self._target_index_pub = rospy.Publisher(
            "target_index", std_msgs.msg.Int64, queue_size=10
        )
        self._timer = rospy.Timer(
            rospy.Duration(1.0 / control_rate), self._timer_callback
        )

    def _state_callback(self, msg):
        """Handle state callback."""
        self._current_state = msg

    def _pose_callback(self, msg):
        """Handle pose callback."""
        self._current_pose = msg
        if self._home_pose is None:
            self._home_pose = self._current_pose
            hover_pose = self._home_pose
            hover_pose.pose.position.z += 1.0

            self._waypoints.append(("HOME", self._home_pose))
            self._waypoints.append(("TAKEOFF", hover_pose))

            pattern = []
            temp_pose = geometry_msgs.msg.PoseStamped()
            temp_pose.pose.position.x = 0.0
            temp_pose.pose.position.y = 0.0
            temp_pose.pose.position.z = 2.0
            temp_pose.pose.orientation.w = 1.0
            temp_pose.pose.orientation.x = 0.0
            temp_pose.pose.orientation.y = 0.0
            temp_pose.pose.orientation.z = 0.0
            pattern.append(("LOWER_RIGHT", temp_pose))

            temp_pose = geometry_msgs.msg.PoseStamped()
            temp_pose.pose.position.x = 0.0
            temp_pose.pose.position.y = self._y_size
            temp_pose.pose.position.z = 2.0
            temp_pose.pose.orientation.w = 1.0
            temp_pose.pose.orientation.x = 0.0
            temp_pose.pose.orientation.y = 0.0
            temp_pose.pose.orientation.z = 0.0
            pattern.append(("UPPER_LEFT", temp_pose))

            temp_pose = geometry_msgs.msg.PoseStamped()
            temp_pose.pose.position.x = self._x_size
            temp_pose.pose.position.y = self._y_size
            temp_pose.pose.position.z = 2.0
            temp_pose.pose.orientation.w = 1.0
            temp_pose.pose.orientation.x = 0.0
            temp_pose.pose.orientation.y = 0.0
            temp_pose.pose.orientation.z = 0.0
            pattern.append(("UPPER_RIGHT", temp_pose))

            temp_pose = geometry_msgs.msg.PoseStamped()
            temp_pose.pose.position.x = self._x_size
            temp_pose.pose.position.y = 0.0
            temp_pose.pose.position.z = 2.0
            temp_pose.pose.orientation.w = 1.0
            temp_pose.pose.orientation.x = 0.0
            temp_pose.pose.orientation.y = 0.0
            temp_pose.pose.orientation.z = 0.0
            pattern.append(("LOWER_LEFT", temp_pose))

            self._waypoints += self._num_repeats * pattern

            self._waypoints.append(("LAND", hover_pose))
            self._waypoints.append(("HOME", self._home_pose))

    def _timer_callback(self, msg):
        """Handle timer."""
        rospy.logwarn_throttle(2.0, "Current state: {}".format(self._waypoint_state))

        if self._waypoint_state == State.WAITING_FOR_HOME:
            if self._home_pose is not None:
                self._waypoint_state = State.WAITING_FOR_ARM
        elif self._waypoint_state == State.WAITING_FOR_ARM:
            if self._current_state is not None and self._current_state.armed:
                self._waypoint_state = State.EXECUTING_MISSION
        elif self._waypoint_state == State.EXECUTING_MISSION:
            if self._last_pose_time is None:
                self._last_pose_time = rospy.Time.now()

            time_diff = rospy.Time.now() - self._last_pose_time
            need_new_waypoint = False

            if self._check_pose():
                need_new_waypoint = True
            elif time_diff > rospy.Duration(self._pose_timeout):
                if self._waypoint_index < len(self._waypoints) - 1:
                    rospy.logerr("Waypoint {} timed out!".format(self._waypoint_index))
                need_new_waypoint = True

            if need_new_waypoint and self._waypoint_index < len(self._waypoints) - 1:
                self._last_pose_time = rospy.Time.now()
                self._waypoint_index += 1
                rospy.logwarn(
                    "Moving to waypoint: {}".format(
                        self._waypoints[self._waypoint_index][0]
                    )
                )
            elif need_new_waypoint:
                rospy.logwarn_throttle(5.0, "Finished path")

            to_send = geometry_msgs.msg.PoseStamped()
            to_send.header.stamp = rospy.Time.now()
            to_send.pose = self._waypoints[self._waypoint_index][1].pose
            self._target_pub.publish(to_send)
            self._target_index_pub.publish(self._waypoint_index)

    def _check_pose(self):
        # waypoint_pose = self._waypoints[self._waypoint_index][1]
        # x_diff = self._current_pose.pose.position.x - waypoint_pose.pose.position.x
        # y_diff = self._current_pose.pose.position.y - waypoint_pose.pose.position.y
        # z_diff = self._current_pose.pose.position.z - waypoint_pose.pose.position.z
        # dist = math.sqrt(x_diff ** 2 + y_diff ** 2 + z_diff ** 2)
        # return dist < self._dist_threshold
        return False

def main():
    """Run everything."""
    rospy.init_node("fly_waypoints")

    node = WaypointNode()

    rospy.spin()


if __name__ == "__main__":
    main()
