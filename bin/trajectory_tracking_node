#!/usr/bin/env python
"""Script to get a positions/velocities/lengths trajectory."""
import intel_aero_ros
import rospy
import numpy as np
import geometry_msgs.msg

import importlib
import pathlib
import sys


def get_trajectory_planner():
    """Import the trajectory planner code."""
    soft_drone_pydir = pathlib.Path(__file__).resolve().parent.parent.parent / "python"
    sys.path.append(str(soft_drone_pydir))
    return importlib.import_module(
        "soft_drone_python.find_trajectory"
    ).find_trajectory_for_interp


tendon_target = None


def pose_handler(msg):
    """Wait for start pose."""
    global tendon_target
    if tendon_target is None:
        tendon_target = np.array(
            [msg.pose.position.x, msg.pose.position.y, msg.pose.position.z]
        )


def main():
    """Run everything."""
    global tendon_target
    rospy.init_node("trajectory_tracking")

    total_time = rospy.get_param("~total_time", 3.0)
    intermediate_distance = rospy.get_param("~intermediate_distance", 0.1)
    learning_rate = rospy.get_param("~learning_rate", 5.0)
    gripper_latency = rospy.get_param("~gripper_latency", 0.0)
    start_gripper_early = rospy.get_param("~start_gripper_early", False)

    planner = get_trajectory_planner()

    # TODO(nathan) make this cleaner
    rospy.logwarn("Waiting for target pose")
    target_sub = rospy.Subscriber(
        "tendon_target", geometry_msgs.msg.PoseStamped, pose_handler, queue_size=10
    )

    while not rospy.is_shutdown() and tendon_target is None:
        rospy.sleep(rospy.Duration(0.1))

    if tendon_target is None:
        rospy.logwarn("ROS shutdown before planning ocurred.")
        return

    rospy.loginfo("Tendon Target before: {}".format(tendon_target))
    mocap_offset = np.array(rospy.get_param("~mocap_offset", [0.25, 0, 0.0]))
    rospy.loginfo("Mocap offset: {}".format(mocap_offset))
    tendon_target = tendon_target + mocap_offset

    start_position = np.array(rospy.get_param("~start_position", [0, 0, 1.5]))
    end_position = tendon_target - np.array(rospy.get_param("~offset", [0, 0, -0.150]))
    start_position[0] = end_position[0]  # force planar trajectory
    end_velocity = np.array(rospy.get_param("~end_velocity", [0, 0, 0]))

    rospy.loginfo("Start: {}".format(start_position))
    rospy.loginfo("End: {}".format(end_position))
    rospy.loginfo("End Velocity: {}".format(end_velocity))
    rospy.loginfo("Tendon Target: {}".format(tendon_target))
    polynomial, lengths = planner(
        start_position,
        end_position,
        tendon_target,
        total_time=total_time,
        intermediate_distance=intermediate_distance,
        intermediate_objective="area",
        end_velocity=end_velocity,
	    L_r=learning_rate,
    )

    print(lengths)

    # Set up the things that will make this run
    trajectory_tracker = intel_aero_ros.InterpTrajectoryTracker(
        polynomial,
        lengths,
        gripper_latency=gripper_latency,
        start_gripper_early=start_gripper_early,
    )
    state_machine = intel_aero_ros.GainTuningStateMachine(trajectory_tracker)  # NOQA

    rospy.spin()


if __name__ == "__main__":
    main()
