#!/usr/bin/env python
"""Script to get a positions/velocities/lengths trajectory"""
import rospy
import geometry_msgs.msg
import mavros_msgs.msg
import std_msgs.msg
import numpy as np
import enum
import serial
import math

import inspect
from os import path, sys
bin_folder = path.realpath(path.abspath(path.dirname(inspect.getfile( inspect.currentframe() ))[:-1]))
ros_folder = path.split(bin_folder)[0]
src_folder = path.split(ros_folder)[0]
python_folder = path.join(src_folder,'python')
if python_folder not in sys.path:
     sys.path.insert(0, python_folder)
print(python_folder)
from soft_drone_python import find_trajectory


class State(enum.Enum):
    WAITING_FOR_HOME = 0
    WAITING_FOR_ARM = 1
    EXECUTING_MISSION = 2


class WaypointNode:
    """Class for sending waypoints to the drone."""

    def __init__(self, arduino):
        """Set everything up."""
        control_rate = rospy.get_param("~control_rate", 100)
        if control_rate < 20.0:
            rospy.logfatal("Invalid control rate, must be above 20 hz")
            rospy.signal_shutdown("invalid control rate")
            return

        self._x_size = rospy.get_param("~x_size", 0.5)
        self._y_size = rospy.get_param("~y_size", 0.5)
        self._num_repeats = rospy.get_param("~num_repeats", 3)
        self._dist_threshold = rospy.get_param("~dist_threshold", 0.2)
        self._waypoint_state = State.WAITING_FOR_HOME
        self._current_state = None
        self._current_pose = None
        self._home_pose = None
        self._waypoints = []
        self._lengths = []
        self._waypoint_index = 0
        self._total_time = 2.5
        self._num_frames = 2
        self._last_pose_time = None
        self._pose_timeout = rospy.get_param("~pose_timeout", 5.0)

        self._state_sub = rospy.Subscriber(
            "state", mavros_msgs.msg.State, self._state_callback, queue_size=10
        )
        self._pose_sub = rospy.Subscriber(
            "pose", geometry_msgs.msg.PoseStamped, self._pose_callback, queue_size=10
        )
        self._target_pub = rospy.Publisher(
            "target", geometry_msgs.msg.PoseStamped, queue_size=10
        )
        self._target_index_pub = rospy.Publisher(
            "target_index", std_msgs.msg.Int64, queue_size=10
        )
        self._timer = rospy.Timer(
            rospy.Duration(1.0 / control_rate), self._timer_callback
        )

        self._arduino = arduino

    def _send_lengths(self, array):
            barray = bytearray([int(a) for a in array])
            msg = 'b' + str(barray) + '\n'
            self._arduino.write(msg)

    def _state_callback(self, msg):
        """Handle state callback."""
        self._current_state = msg

    def _pose_callback(self, msg):
        """Handle pose callback."""
        self._current_pose = msg
        if self._home_pose is None:
            self._home_pose = self._current_pose
            hover_pose = self._home_pose
            hover_pose.pose.position.z += 1.0

            start_position = np.array([hover_pose.pose.position.x, hover_pose.pose.position.y, hover_pose.pose.position.z])
            end_position = start_position + np.array([0.5, 0.0, -0.0])
            tendon_target = end_position + np.array([0, 0, -.150])

            print("Planning trajectory...")
            positions, velocities, lengths = find_trajectory.find_trajectory(start_position, end_position, tendon_target, 
                                                             total_time=self._total_time, num_frames=self._num_frames)
            print("Planned trajectory.")

            self._waypoints.append(("HOME", self._home_pose))
            self._waypoints.append(("TAKEOFF", hover_pose))

            for i, position in enumerate(positions):
                temp_pose = geometry_msgs.msg.PoseStamped()
                temp_pose.pose.position.x = position[0]
                temp_pose.pose.position.y = position[2]
                temp_pose.pose.position.z = position[2]
                temp_pose.pose.orientation.w = 1.0
                temp_pose.pose.orientation.x = 0.0
                temp_pose.pose.orientation.y = 0.0
                temp_pose.pose.orientation.z = 0.0
                self._waypoints.append(('Trajectory {}'.format{i}, temp_pose))

            self._waypoints.append(("LAND", hover_pose))
            self._waypoints.append(("HOME", self._home_pose))
            self._lengths = lengths

    def _timer_callback(self, msg):
        """Handle timer."""
        rospy.logwarn_throttle(2.0, "Current state: {}".format(self._waypoint_state))

        if self._waypoint_state == State.WAITING_FOR_HOME:
            if self._home_pose is not None:
                self._waypoint_state = State.WAITING_FOR_ARM
        elif self._waypoint_state == State.WAITING_FOR_ARM:
            if self._current_state is not None and self._current_state.armed:
                self._waypoint_state = State.EXECUTING_MISSION
        elif self._waypoint_state == State.EXECUTING_MISSION:
            if self._last_pose_time is None:
                self._last_pose_time = rospy.Time.now()

            time_diff = rospy.Time.now() - self._last_pose_time
            need_new_waypoint = False

            if self._check_pose():
                need_new_waypoint = True
            elif time_diff > rospy.Duration(self._pose_timeout):
                if self._waypoint_index < len(self._waypoints) - 1:
                    rospy.logerr("Waypoint {} timed out!".format(self._waypoint_index))
                need_new_waypoint = True

            if need_new_waypoint and self._waypoint_index < len(self._waypoints) - 1:
                self._last_pose_time = rospy.Time.now()
                self._waypoint_index += 1
                rospy.logwarn(
                    "Moving to waypoint: {}".format(
                        self._waypoints[self._waypoint_index][0]
                    )
                )
            elif need_new_waypoint:
                rospy.logwarn_throttle(5.0, "Finished path")

            to_send = geometry_msgs.msg.PoseStamped()
            to_send.header.stamp = rospy.Time.now()
            to_send.pose = self._waypoints[self._waypoint_index][1].pose
            self._target_pub.publish(to_send)
            self._target_index_pub.publish(self._waypoint_index)

            tendon_index = self._waypoint_index - 2
            if tendon_index < self._num_frames:
                self._send_lengths(self._lengths[tendon_index])

    def _check_pose(self):
        waypoint_pose = self._waypoints[self._waypoint_index][1]
        x_diff = self._current_pose.pose.position.x - waypoint_pose.pose.position.x
        y_diff = self._current_pose.pose.position.y - waypoint_pose.pose.position.y
        z_diff = self._current_pose.pose.position.z - waypoint_pose.pose.position.z
        dist = math.sqrt(x_diff ** 2 + y_diff ** 2 + z_diff ** 2)
        return dist < self._dist_threshold

def main():
    """Run everything."""
    port = "/dev/ttyACM0"
    baud_rate = 57600
    with serial.Serial(port, baud_rate, timeout=.1) as arduino:
        rospy.init_node("fly_waypoints")

        node = WaypointNode(arduino)

        rospy.spin()


if __name__ == "__main__":
    main()
